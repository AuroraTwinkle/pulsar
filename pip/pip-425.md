# PIP-425: fix problem that consumer or producer create failed when many nodes in PulsarClient serviceUrl become unavailable
Implementation PR: [#24387](https://github.com/apache/pulsar/pull/24387)

# Background knowledge
In the current Pulsar client versions, consumer or producer creation is the responsibility of PulsarClient, we can build a PulsarClient by pass serviceUrl param:

```java
public class Example {
    public static void main(String[] args) throws PulsarClientException {
        PulsarClient pulsarClient = PulsarClient.builder()
                .serviceUrl("pulsar://localhost1:6650,localhost2:6650,localhost3:6650")
                .build();
        Consumer<Long> consumer = pulsarClient.newConsumer(Schema.INT64)
                .topic("persistent://public/default/my-topic")
                .subscriptionName("my-subscription")
                .subscribe();

        Producer<Long> producer = pulsarClient.newProducer(Schema.INT64)
                .topic("persistent://public/default/my-topic")
                .create();   

        .....

    }
}

```

# Motivation

As [#22934 ](https://github.com/apache/pulsar/issues/22934) and [#22933](https://github.com/apache/pulsar/discussions/22933) mentioned, when most of the nodes in serviceurl are down (but there is at least one available node), creating consumers and producers through PulsarClient will most likely fail. I think this is not as expected. If the code is robust enough, as long as there is one available node, it should be accessible normally. Therefore, this pip is going to optimize the code logic, remove unavailable nodes through the feedback mechanism, and improve the success rate of PulsarClient requests.

By the way, [#22935](https://github.com/apache/pulsar/pull/22935) removes faulty nodes through a regular health check mechanism, but this brings new problems (frequent creation of connections and increased system load), so this solution is abandoned. See #22934 (comment) for more details!



# Goals
Optimize the PulsarClient code logic, remove unavailable serviceUrl nodes through the feedback mechanism, and improve the success rate of PulsarClient requests.

## In Scope
If this pip is accepted, it will help improve the PulsarClient success rate of consumer or producer creation, even if most of the nodes in serviceurl are no longer available.

# Detailed Design
**Explanation of nouns:**
- `availableAddressPool`: a pool containing all available addresses, subset of serviceUrl.
- `originAddressPool`: a pool containing all addresses in serviceUrl.

## Design & Implementation Details
As [#22934](https://github.com/apache/pulsar/issues/22934#issuecomment-2943690398) mentioned, add `markHostAvailability` method in `ServiceNameResolver` interface like:
```java
    /**
     * Mark the availability of a host.
     * @param address the host address to mark availability for
     * @param isAvailable true if the host is available, false otherwise
     */
    default void markHostAvailability(InetSocketAddress address, boolean isAvailable){
        // Default implementation does nothing
        // Subclass can override this method to implement host availability tracking
    }
```
When resolve one address in serviceUrl, the `ConnectionPool` will invoke `markHostAvailability` to tell availability about that address, so the `ServiceNameResolver` can remove it from `availableAddressPool` if unavailable (or recover back to `availableAddressPool` if available). If all addressed in  `availableAddressPool` are unavailable, the resolver implementation could start getting random addresses from the `originAddressPool`.

For addresses removed from `availableAddressPool`, will retry according to the exponential avoidance interval strategy, avoid the problem that the failed address cannot be resolved again after recovery. The retry interval can be customized via new optional configurations `serviceUrlRecoveryInitBackoffInterval` and `serviceUrlRecoveryMaxBackoffInterval` in `ClientBuilder`



### Usage Example
```java
    private void example() throws PulsarClientException {
        // The failed node will be removed and retried after a period of time, with an initial interval of 30 seconds increasing exponentially. After reaching the maximum interval of 1 hour, the retry will be maintained once an hour until a certain retry succeeds, and the retry interval is reset to 0.
        PulsarClient pulsarClient = PulsarClient.builder()
                .serviceUrl("pulsar://localhost1:6650,localhost2:6650,localhost3:6650")
                .serviceUrlRecoveryInitBackoffInterval(30000, TimeUnit.MILLISECONDS)
                .serviceUrlRecoveryMaxBackoffInterval(1, TimeUnit.HOURS)
                .build();    

        // disable removing unavailable serviceUrl nodes by pass 0 to serviceUrlRecoveryInitBackoffInterval and serviceUrlRecoveryMaxBackoffInterval
        PulsarClient pulsarClientDisableReovery = PulsarClient.builder()
                .serviceUrl("pulsar://localhost1:6650,localhost2:6650,localhost3:6650")
                .serviceUrlRecoveryInitBackoffInterval(0, TimeUnit.MILLISECONDS)
                .serviceUrlRecoveryMaxBackoffInterval(0, TimeUnit.MILLISECONDS)
                .build();                
}

```
## Public-facing Changes

### Public API

1. Add two optional configs `serviceUrlRecoveryInitBackoffInterval` and `serviceUrlRecoveryMaxBackoffInterval` in `ClientBuilder`
```java
    /**
     * Configure the service URL recovery init backoff intervals.
     *
     * <p>When the client is unable to connect to the service URL, it will wait for a certain amount of time before
     * trying to recover the service URL. The init backoff intervals can be configured using this method.
     *
     * <p>
     * A value of 0 means don't need wait before retrying to connect to the failed service URL.
     * @param serviceUrlRecoveryInitBackoffInterval the initial backoff interval for service URL recovery
     * @param unit the time unit for the backoff interval
     * @return the client builder instance
     */
    ClientBuilder serviceUrlRecoveryInitBackoffInterval(long serviceUrlRecoveryInitBackoffInterval, TimeUnit unit);

    /**
     * Configure the service URL recovery max backoff interval.
     *
     * <p>When the client is unable to connect to the service URL, it will wait for a certain amount of time before
     * trying to recover the service URL. The max backoff interval can be configured using this method.
     *
     * <p>
     * A value of 0 means don't need wait before retrying to connect to the failed service URL.
     * @param serviceUrlRecoveryMaxBackoffInterval the maximum backoff interval for service URL recovery
     * @param unit the time unit for the backoff interval
     * @return the client builder instance
     */
    ClientBuilder serviceUrlRecoveryMaxBackoffInterval(long serviceUrlRecoveryMaxBackoffInterval, TimeUnit unit);
```

# Backward & Forward Compatibility
You can do upgrading or reverting normally, no specified steps are needed to do.

# Links

* Mailing List discussion thread: 
* Mailing List voting thread: 
