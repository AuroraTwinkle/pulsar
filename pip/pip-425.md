# PIP-425: Support connecting with next available endpoint for multi-endpoint serviceUrls
Implementation PR: [#24387](https://github.com/apache/pulsar/pull/24387)

# Background knowledge
In the current Pulsar client versions, consumer or producer creation is the responsibility of PulsarClient, we can build a PulsarClient by pass serviceUrl param. The serviceUrl param supports multiple endpoints with the syntax `pulsar://localhost1:6650,localhost2:6650,localhost3:6650,...` or `pulsar+ssl://localhost1:6650,localhost2:6650,localhost3:6650,...`. What happens if some of the endpoints are unavailable? Yes, in the current version, it may cause the consumer or producer to fail to create, which is also the optimization goal of this pip.

```java
public class Example {
    public static void main(String[] args) throws PulsarClientException {
        PulsarClient pulsarClient = PulsarClient.builder()
                .serviceUrl("pulsar://localhost1:6650,localhost2:6650,localhost3:6650")
                .build();
        Consumer<Long> consumer = pulsarClient.newConsumer(Schema.INT64)
                .topic("persistent://public/default/my-topic")
                .subscriptionName("my-subscription")
                .subscribe();

        Producer<Long> producer = pulsarClient.newProducer(Schema.INT64)
                .topic("persistent://public/default/my-topic")
                .create();   

        .....

    }
}

```

# Motivation

As [#22934 ](https://github.com/apache/pulsar/issues/22934) and [#22933](https://github.com/apache/pulsar/discussions/22933) mentioned, when most of the endpoints in serviceurl are unavilable (but there is at least one available endpoint), creating consumers and producers through PulsarClient will most likely fail. I think this is not as expected. If the code is robust enough, as long as there is one available endpoint, it should be accessible normally. Obviously, we can remove unavailable endpoints through some mechanism, and try to ensure the next connection to an available endpoint. 


# Goals
Optimize the PulsarClient code logic, remove unavailable serviceUrl endpoints through the feedback mechanism, and improve the success rate of PulsarClient requests.

## In Scope
If this pip is accepted, it will help improve the PulsarClient success rate of consumer or producer creation, even if most of the endpoints in serviceurl are no longer available.

## Out of Scope
[#22935](https://github.com/apache/pulsar/pull/22935) removes unavailable endpoints through a regular health check mechanism, but this brings new problems (frequent creation of connections and increased system load). So this pip will not use the health check solution.

# Detailed Design
**Explanation of nouns:**
- `availableAddressPool`: a pool containing all available addresses, subset of serviceUrl.
- `allAddressPool`: a pool containing all addresses in serviceUrl.

## Design & Implementation Details
As [#22934](https://github.com/apache/pulsar/issues/22934#issuecomment-2943690398) mentioned, add `markHostAvailability` method in `ServiceNameResolver` interface like:
```java
    /**
     * Mark the availability of a host.
     * @param address the host address to mark availability for
     * @param isAvailable true if the host is available, false otherwise
     */
    default void markHostAvailability(InetSocketAddress address, boolean isAvailable){
        // Default implementation does nothing
        // Subclass can override this method to implement host availability tracking
    }
```
When resolve one address in serviceUrl, the `ConnectionPool` will invoke `markHostAvailability` to tell availability about that address, so the `ServiceNameResolver` can remove it from `availableAddressPool` if unavailable (or recover back to `availableAddressPool` if available). If all addressed in  `availableAddressPool` are unavailable, the resolver implementation could start getting random addresses from the `allAddressPool`.

For removed addresses, the quarantine duration will increase exponentially. The quarantine duration can be customized via new optional configurations `serviceUrlInitFaultQuarantineDuration` and `serviceUrlMaxFaultQuarantineDuration` in `ClientBuilder`
That is to say, assuming that `serviceUrlInitFaultQuarantineDuration` is 1 minute and `serviceUrlMaxFaultQuarantineDuration` is 30 minutes, after host1 is judged as unavailable for the first time, it will be isolated for 1 minute and then added to `availableAddressPool` again. If it is judged as unavailable again the next time, it will be isolated for 2 minutes. Similarly, if it is judged as unavailable continuously, the isolation time will be 4 minutes, 8 minutes, 16 minutes, 30 minutes (it reaches serviceUrlMaxFaultQuarantineDuration and no longer increases), 30 minutes... If host1 is determined to be available, the next quarantine duration will be reset to 1 minute.


### Usage Example
```java
    private void example() throws PulsarClientException {
        // The failed endpoint will be removed and retried after a period of time, with an initial quarantine duration of 30 seconds increasing exponentially. After reaching the maximum quarantine duration of 1 hour, will be maintained once an hour until a certain succeeds, and the quarantine duration is reset to 0.
        PulsarClient pulsarClient = PulsarClient.builder()
                .serviceUrl("pulsar://localhost1:6650,localhost2:6650,localhost3:6650")
                .serviceUrlInitFaultQuarantineDuration(30000, TimeUnit.MILLISECONDS)
                .serviceUrlMaxFaultQuarantineDuration(1, TimeUnit.HOURS)
                .build();    

        // disable removing unavailable serviceUrl endpoints by pass 0 to serviceUrlInitFaultQuarantineDuration and serviceUrlMaxFaultQuarantineDuration
        PulsarClient pulsarClientDisableReovery = PulsarClient.builder()
                .serviceUrl("pulsar://localhost1:6650,localhost2:6650,localhost3:6650")
                .serviceUrlInitFaultQuarantineDuration(0, TimeUnit.MILLISECONDS)
                .serviceUrlMaxFaultQuarantineDuration(0, TimeUnit.MILLISECONDS)
                .build();                
}

```
## Public-facing Changes

### Public API

1. Add two optional configs `serviceUrlInitFaultQuarantineDuration` and `serviceUrlMaxFaultQuarantineDuration` in `ClientBuilder`
```java
    /**
     * Configure the service URL init fault quarantine duration.
     *
     * <p>When the client is unable to connect to the service URL, it will wait for a certain amount of time before
     * trying to recover the service URL endpoint. The init quarantine duration can be configured using this method.
     *
     * <p>
     * A value of 0 means don't need wait before retrying to connect to the failed service URL endpoint.
     * @param serviceUrlInitFaultQuarantineDuration the initial quarantine duration for unavailable service URL endpoint
     * @param unit the time unit for the quarantine duration
     * @return the client builder instance
     */
    ClientBuilder serviceUrlInitFaultQuarantineDuration(long serviceUrlInitFaultQuarantineDuration, TimeUnit unit);

    /**
     * Configure the service URL max fault quarantine duration.
     *
     * <p>When the client is unable to connect to the service URL, it will wait for a certain amount of time before
     * trying to recover the service URL endpoint. The max quarantine duration can be configured using this method.
     *
     * <p>
     * A value of 0 means don't need wait before retrying to connect to the failed service URL endpoint.
     * @param serviceUrlMaxFaultQuarantineDuration the maximum quarantine duration for unavailable service URL endpoint
     * @param unit the time unit for the quarantine duration
     * @return the client builder instance
     */
    ClientBuilder serviceUrlMaxFaultQuarantineDuration(long serviceUrlMaxFaultQuarantineDuration, TimeUnit unit);
```

# Backward & Forward Compatibility
You can do upgrading or reverting normally, no specified steps are needed to do.

# Links

* Mailing List discussion thread: 
* Mailing List voting thread: 
